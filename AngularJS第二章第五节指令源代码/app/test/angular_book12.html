<!doctype html>
<html ng-app="MyApp">

<head>
    <meta charset="utf-8">
</head>

<body>
<div>
    //可以在视图中将clock变量用{{ }}包起来，以显示$scope中的clock的值：

    //通常认为，在视图中通过对象的属性而非对象本身来进行引用绑定，是Angular中的最佳实践。

    //将应用的业务逻辑都放在控制器中，而将相关的数据都放在控制器的作用域中，这是非常完美的架构。

    //AngularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定。$rootScope是所有$scope对象的最上层

    //$scope的所有属性，都可以自动被视图访问到

    //AngularJS通过作用域将视图、控制器和指令（本书后面会介绍）隔离开来，这样就很容易为功能的具体部分编写测试。

    //控制器应该尽可能保持短小精悍，而在控制器中进行DOM操作和数据操作则是一个不好的实践。

    /////////////////////表达式////////////////////
    1.所有的表达式都在其所属的作用域内部执行，并有访问本地$scope的权限
    2.如果表达式发生了TypeError和ReferenceError并不会抛出异常；
    3.不允许使用任何流程控制功能（条件控制，例如if/eles）
    4.可以接受过滤器和过滤器链

    ////////////////////指令/////////////////////
    1.指令本质上就是AngularJS扩展具有自定义功能的HTML元素的途径
    2.无论有多少种方式可以声明指令，我们坚持使用属性方式，因为它有比较好的跨浏览器兼容性：
    3.还有其他内置指令（比如ng-include和ng-view）也会创建新的子作用域，这意味着
    它们在被调用时行为和ng-controller类似。我们在构造自定义指令时也可以创建新的子作用域

    4.在主HTML文档中，可以给指令添加myUrl和myLinkText两个属性，这两个参数会成为指令
    内部作用域的属性：
    <div my-directive
         my-url="http://google.com"
         my-link-text="Click me to go to Google">
    </div>

    5.实际上创造的是隔离作用域。本质上，意味着指令有了一个属于自己的$scope对象，这个对
    象只能在指令的方法中或指令的模板字符串中使用：

    ///////////////////内置指令///////////////////
    1.ng-href和ng-src都能有效帮助重构和避免错误，因此在改进代码时强烈建议用它们代替原
    来的href和src属性

    2.ng-app为AngularJS应用创建$rootScope，ng-controller则会以$rootScope或另外一个
    ng-controller的作用域为原型创建新的子作用域。
    2.1.任何具有ng-app属性的DOM元素将被标记为$rootScope的起始点。
    $rootScope是作用域链的起始点，任何嵌套在ng-app内的指令都会继承它。

    2.2.内置指令ng-controller的作用是为嵌套在其中的指令创建一个子作用域，避免将所有操作
    和模型都定义在$rootScope上

    2.3.出于技术和架构方面的原因，绝对不要直接将控制器中的$scope赋值为值类型
    对象（字符串、布尔值或数字）。DOM中应该始终通过点操作符.来访问数据。
    遵守这个规则将使你远离不可预期的麻烦。

    3.使用ng-include时AngularJS会自动创建一个子作用域。如果你想使用某个特定的作
    用域，例如ControllerA的作用域，必须在同一个DOM元素上添加ng-controller ="ControllerA"
    指令，这样当模板加载完成后，不会像往常一样从外部作用域继承并创建一个新的子作用域

    4.ng-init指令用来在指令被调用时设置内部作用域的初始状态。

    5.{{ }}语法是AngularJS内置的模板语法，它会在内部$scope和视图之间创建绑定。基于这个
    绑定，只要$scope发生变化，视图就会随之自动更新。
    事实上它也是指令，虽然看起来并不像，实际上它是ng-bind的简略形式，用这种形式不需
    要创建新的元素，因此它常被用在行内文本中。

    6.尽管可以在视图中使用{{ }}模板语法（AngularJS内置的方式），我们也可以通过ng-bind
    指令实现同样的行为。

    7.同ng-bind指令类似，ng-bind-template用来在视图中绑定多个表达式。
    <div ng-bind-template=''> </div>

    8.ng-model指令用来将input、select、text area或自定义表单控件同包含它们的作用域中
    的属性进行绑定。它可以提供并处理表单验证功能，在元素上设置相关的CSS类（ng-valid、
    ng-invalid等），并负责在父表单中注册控件。
    它将当前作用域中运算表达式的值同给定的元素进行绑定。如果属性并不存在，它会隐式创
    建并将其添加到当前作用域中。

    9.ng-form用来在一个表单内部嵌套另一个表单.

    10.使用ng-class 动态设置元素的类，方法是绑定一个代表所有需要添加的类的表达式。重复
    的类不会添加。当表达式发生变化，先前添加的类会被移除，新类会被添加

    ////////////////////////指令详解/////////////////////////////
    1.template参数是可选的，必须被设置为以下两种形式之一
    如果模板字符串中含有多个DOM元素，或者只由一个单独的文本节点构成，那它必须被包
    含在一个父元素内。

    2.绑定策略
    本地作用域属性：使用@符号将本地作用域同DOM属性的值进行绑定。指令内部作用域可以
    使用外部作用域的变量：@ (or @attr)

    双向绑定：通过=可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定。
    就像普通的数据绑定一样，本地属性会反映出父数据模型中所发生的改变
    = (or =attr)

    父级作用域绑定 通过&符号可以对父级作用域进行绑定，以便在其中运行函数。意味着对这
    个值进行设置时会生成一个指向父级作用域的包装函数
    & (or &attr)

    3.transclude是一个可选的参数。如果设置了，其值必须为true，它的默认值是false。
    嵌入有时被认为是一个高级主题，但某些情况下它与我们刚刚学习过的作用域之间会有非常
    好的配合。使用嵌入也会很好地扩充我们的工具集，特别是在创建可以在团队、项目、AngularJS
    社区之间共享的HTML代码片段时

    4.require参数可以被设置为字符串或数组，字符串代表另外一个指令的名字。require会将控
    制器注入到其值所指定的指令中，并作为当前指令的链接函数的第四个参数。
    4.1.require参数的值可以用下面的前缀进行修饰，这会改变查找控制器时的行为：

    (?)如果在当前指令中没有找到所需要的控制器，会将null作为传给link函数的第四个参数。

    (^)如果添加了^前缀，指令会在上游的指令链中查找require参数所指定的控制器。

    (?^)将前面两个选项的行为组合起来，我们可选择地加载需要的指令并在父指令链中进行查找。

    5.ngModel是一个用法特殊的指令，它提供更底层的API来处理控制器内的数据。当我们在指令
    中使用ngModel时能够访问一个特殊的API，这个API用来处理数据绑定、验证、CSS更新等不实
    际操作DOM的事情。

    如果不设置require选项，ngModelController就不会被注入到指令中

    注意，这个指令没有隔离作用域。如果给这个指令设置隔离作用域，将导致内部ngModel无
    法更新外部ngModel的对应值：AngularJS会在本地作用域以外查询值。

    /////////////////////模块加载//////////////////////////////
    .config():当对模块进行配置时，需要格外注意只有少数几种类型的对象可以被注入到config()函数
    中：提供者和常量。

    .run():和配置块不同，运行块在注入器创建之后被执行，它是所有AngularJS应用中第一个被执行
    的方法。
    运行块是AngularJS中与main方法最接近的概念。运行块中的代码块通常很难进行单元测试，
    它是和应用本身高度耦合的。

    /////////////////服务///////////////////////////////////
    1.出于内存占用和性能的考虑，控制器只会在需要时被实例化，并且不再需要就会被销毁。这意味
    着每次切换路由或重新加载视图时，当前的控制器会被AngularJS清除掉。

    2.服务提供了一种能在应用的整个生命周期内保持数据的方法，它能够在控制器之间进行通
    信，并且能保证数据的一致性。

    3.服务是一个单例对象，在每个应用中只会被实例化一次（被$injector实例化），并且是延迟
    加载的（需要时才会被创建）。服务提供了把与特定功能相关联的方法集中在一起的接口。

    4.使用服务也是在控制器之间共享数据的典型方法。

    5.使用service()可以注册一个支持构造函数的服务，它允许我们为服务对象注册一个构造函数。

    6.constant('apiKey','123123123')和.value('apiKey','123123123')可以注册常量服务。

    value()方法和constant()方法之间最主要的区别是，常量可以注入到配置函数中，而值不行。

    通常情况下，可以通过value()来注册服务对象或函数，用constant()来配置数据。

    ////////////////事件////////////////////////////////////////
    1.Angular的作用域在本质上是分层次的：它们可以通过父子关系很自然地来回沟通。但通常，
    作用域是不共享变量的，它们执行的功能往往各不相同，跟在父树上的位置无关。
    在这种情况下，我们可以通过在这个链上传递事件的方式在作用域之间通信。

    注意，Angular事件系统并不与浏览器的事件系统相通，这意味着，我们只能在
    作用域上监听Angular事件而不是DOM事件。

    2.要把事件沿着作用域链向上派送（从子作用域到父作用域），我们要使用$emit()函数。
    scope.$emit('user:logged_in', scope.user);
    在一个$emit()事件函数的调用中，事件从子作用域冒泡到父作用域。在产生事件的作用域
    之上的所有作用域都会收到这个事件的通知。

    3.使用$broadcast向下传递事件
    要把事件向下传递（从父作用域到子作用域），我们使用$broadcast()函数。
    scope.$broadcast('cart:checking_out', scope.cart);
    在$broadcast()方法上，每个注册了监听器的子作用域都会收到这个信息。事件传播到所
    有的指令和当前作用域的间接作用域上，并且一路往下调用每个监听器。

    4.要监听一个事件，我们可以使用$on()方法。这个方法为具有某个特定名称的事件注册了一
    个监听器。事件名称就是在Angular中触发的事件类型。
    scope.$on('$routeChangeStart',
    function(evt, next, current) {
    // 一个新的路由被触发了
    });
    Angular把evt对象作为第一个参数传给正在监听的一切事件，不管它是我们自定义的事件还
    是内置的Angular服务。

    5.事件对象
    1. targetScope（作用域对象）
    这个属性是发送或者广播事件的作用域。
    2. currentScope（作用域对象）
    这个对象包含了当前处理事件的作用域。
    3. name（字符串）
    这个字符串是触发之后，我们正在处理的事件名称。
    4. stopPropagation（函数）
    stopPropagation()函数取消通过$emit触发的事件的进一步传播。
    5. preventDefault（函数）
    preventDefault把defaultPrevented标志设置为true。尽管不能停止事件的传播，我们可
    以告诉子作用域无需处理这个事件（也就是说，可以安全地忽略它们）。
    6. defaultPrevented（布尔值）
    调用preventDefault()会把defaultPrevented设置为true。
    $on()函数返回了一个反注册函数，我们可以调用它来取消监听器。

    6.在控制器之间共享数据。
    1.在Angular里，我们可以通过几种不同的方式在控制器之间传递数据。我们可以把控制器嵌
    套在同一个父控制器中，允许每个控制器独立修改父控制器$scope上的属性值，或者可以在服务
    中共享数据。
    尽量把数据存在服务内部，但是更好的方式要视情况而定。比如说，在一个对话框里，把正
    在显示的数据放在父控制器里更有道理。

    2.指令并不一定要有视图模板。通常情况下，它们可以只作为视图之下处理数据的垫片。

    7.digest循环和$apply
    1.同一时间不能运行两个事件。浏览器会等待前一个事件处理程序执行完成，再
    调用下一个事件处理程序。

    2.$scope对象上的属性只会在其被用于视图时绑定。在上述例子中，我们只给$watch列表添加
    了一个函数。

    对于所有绑定给同一$scope对象的UI元素，只会添加一个$watch到$watch列表中.

    3.当我们将jQuery和Angular集成在一起时（这通常被视为一个肮脏的行为），就需要使用
    $apply()，因为Angular不会察觉到执行在Angular上下文外部的事件。例如，在使用jQuery插件
    时（比如datepicker），就需要使用$apply()将来自jQuery的值传递到Angular应用中。

    ng表达式：+，-，*，/,&...但是不支持if/for/while等控制逻辑。

    控制逻辑一般用指令实现:ng-if,ng-repeat。

</div>
</body>
</html>






